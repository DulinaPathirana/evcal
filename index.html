<!DOCTYPE html>

    
function  readMatrix(){      const  A = Array.from({length: SIZE}, () => Array(SIZE).fill(0));      for(let  r=0;r<SIZE;r++){        for(let  c=0;c<SIZE;c++){          const  idx=r*SIZE+c;          const  val=parseFloat(grid.children[idx].value||'0');          A[r][c]=isFinite(val)?val:0;        }      }      return  A;    }
    function  powerIteration(A,maxIter=1000,tol=1e-10){      const  n=A.length;let  v=Array(n).fill(0);v[0]=1;let  lambda=0;      for(let  k=1;k<=maxIter;k++){        const  w=Array(n).fill(0);        for(let  i=0;i<n;i++){let  sum=0;for(let  j=0;j<n;j++)sum+=A[i][j]*v[j];w[i]=sum;}        const  absw=w.map(Math.abs);const  m=Math.max(...absw);if(m===0)break;        const  vNext=w.map(x=>x/m);const  diff=vNext.map((x,i)=>Math.abs(x-v[i]));        const  err=Math.max(...diff);v=vNext;lambda=m;if(err<tol)return{lambda,v,iterations:k}      }      return{lambda,v,iterations:1000}    }
    function  formatVector(v){return  v.map((x,i)=>`v${i+1}: ${Number(x).toLocaleString(undefined,{maximumFractionDigits:6})}`).join('\n')}
    function  calculateEigenvalue(){      const  A=readMatrix();      const  {lambda,v,iterations}=powerIteration(A);      document.getElementById('results').classList.remove('hidden');      document.getElementById('eigenvalue').textContent=Number(lambda).toLocaleString(undefined,{maximumFractionDigits:10});      document.getElementById('iterations').textContent=iterations;      document.getElementById('eigenvector').textContent=formatVector(v);      updateProjection();    }
    const  years=[2015,2020,2025,2030,2035,2040,2045,2050];    
    function  updateProjection(){      const  evSpan=document.getElementById('eigenvalue');      const  proj=document.getElementById('projection');      const  projBody=document.getElementById('projectionBody');      const  p0Input=document.getElementById('p0');      const  lam=parseFloat((evSpan.textContent||'').replace(/,/g,''));      const  P0=parseFloat(p0Input.value||'');      if(!isFinite(lam)||lam<=0||!isFinite(P0)||P0<0){        proj.classList.add('hidden');        projBody.innerHTML='';        return;      }      const  g=Math.pow(lam,1/5);      projBody.innerHTML='';      years.forEach((year,idx)=>{        const  t=idx;const  pt=P0*Math.pow(g,t);        const  tr=document.createElement('tr');        const  tdYear=document.createElement('td');tdYear.textContent=String(year);tdYear.style.textAlign='left';        const  tdVal=document.createElement('td');tdVal.textContent=Number(pt).toLocaleString(undefined,{maximumFractionDigits:6});        tr.appendChild(tdYear);tr.appendChild(tdVal);projBody.appendChild(tr);      });      proj.classList.remove('hidden');    }
    document.getElementById('p0').addEventListener('input',updateProjection);
  >
